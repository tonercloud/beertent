Hello Chris,

thanks for the sources and the DB. I'm trying to send this email as HTML to
use highlighted code samples, please let me know if it got screwed.

I've taken a look at the database and it seems that all three -- beers,
pubs and breweries -- they all follow the same schema. So when you
implement the breweries, just follow the same idea and you'll get the rest.

I guess on BreweryDetailsPage you want to show all brewery_info entries
where locid equals to the one selected by a user, locid is actually a
primary key in breweries table. So you won't need any extra ListViews or
models in your BreweryDetailsPage.qml. Just follow the same pattern as you
did for BreweryListPage.qml. I'd go with this simplistic file as the start:

import QtQuick 2.0import Sailfish.Silica 1.0

Page {
    id: brewerydetailspage

    SilicaListView {
        id: listView
        model: breweryInfomodel
        anchors.fill: parent
        header: PageHeader {
            title: "Brewery Details"
        }
        delegate: ListItem {
            id: delegate

            Label {
                x: Theme.paddingLarge
                wrapMode: Text.WordWrap
                text: model.locfieldvalue
                color: delegate.highlighted ? Theme.highlightColor :
Theme.primaryColor
            }

        }
    }
}


I've encountered a problem with this particular delegate --- the database
contains multiline strings in locfieldvalue and the label doesn't seem to
resize itself, so the address text overlaps with the next list item
sometimes.

Note that breweryInfomodel will contain only the rows describing a single
brewery. Now to populate this model you can go several ways.

1. Using QSortFilterProxyModel.

Qt has a QSortFilterProxyModel
<http://doc.qt.io/qt-5/qsortfilterproxymodel.html> class to wrap other
models in order to filter and/or sort their data. All you have to do is to
pass an instance of a model you want to filter to QSortFilterProxyModel and
then call one of the following methods: setFilterFixedString,
setFilterRegExp or setFilterWildcard. It operates on strings, so I guess it
converts internally numeric values to strings and then does the filtering
itself. I presume this class was made for GUI tables in the first place.

You already have an SqlQueryModel instance for brewery_info table, it
selects all the data regardless of locid selected by user. So now you have
to filter only those that have locid equal to some value. Wrap your
existing instance into a QSortFilterProxyModel instance like this:

    // beerguide.cpp
    // create a QSortFilterProxyModel instance
    QSortFilterProxyModel* breweryInfoModelFiltered = new
QSortFilterProxyModel(0);
    // set your existing model as a source for filtering proxy
    breweryInfoModelFiltered->setSourceModel(breweryInfomodel);
    // set that subsequent filtering calls operate on the first column (locid)
    breweryInfoModelFiltered->setFilterKeyColumn(0);


Now you may pass the filtering proxy to QML instead of breweryInfomodel
since unfiltered data won't be needed in QML:

    // beerguide.cpp
    view->rootContext()->setContextProperty("breweryInfomodel",
breweryInfoModelFiltered);



Now in your QML whenever a user selects a brewery you may do the following
(I've modified BreweryListPage.qml but you can do it in any other place
appropriate):

    function passbreweryDetails(breweryDetails)
    {
        console.log("about to push to BreweryDetailsPage, for brewery
- locid: " +
                    breweryDetails.locid + ", locname: " +
breweryDetails.locname)

        // this is where filtering happens. breweryInfomodel will
contain only a few rows
        breweryInfomodel.setFilterFixedString(breweryDetails.locid);

        pageStack.push(Qt.resolvedUrl("BreweryDetailsPage.qml"),
                       { breweryDetails : breweryDetails });
    }



Note that breweryInfomodel is now an instance of QSortFilterProxyModel.
QSortFilterProxyModel::setFilterFixedString is declared as a public slot so
you can call it from QML directly without subclassing and adding
Q_INVOKABLE to it. After data is filtered the QSortFilerProxyModel emits
all the signals necessary to reflect changes in QML, so no manual
intervention needed.

2. Modifying current SqlQueryModel implementation.

Retrieving the rows needed from brewery_info should effectively execute the
following SQL statement:

    SELECT * FROM brewery_info WHERE locid = :locid

where :locid is the value of locid selected by a user.

You have already subclassed the QSqlQueryModel and provided a SELECT
statement to it, so all you need to do is to add WHERE clause to the query.
The problem here is that QSqlQueryModel doesn't have means of adding
parameters to an underlying query. My solution would be to reset the query
and reselect data upon user request. The very first intention would be to
add a filter(int locid) method to SqlQueryModel class which adds WHERE
locid = :locid to your select statement but this would break the tables
that don't have this field. Moreover, you have to store the SELECT clause
somewhere in order to keep it immutable. So on the second thought you might
end up with this:

    // sqlquerymodel.h
    class SqlQueryModel
    {
        // ...
    public:
        explicit SqlQueryModel(QString baseQuery, QObject *parent = 0)
            : QSqlQueryModel(parent),
              m_baseQuery(baseQuery)
        {
        }

        Q_INVOKABLE void filter(QString column, int value)
        {
            setQuery(m_baseQuery + " WHERE " + column + " = " +
QString::number(value);
        }
        // ...
    private:
        QString m_baseQuery;
    };


Now to use this you modify the constructing calls in beerguide.cpp so that
the SELECT clause of the statement is stored in m_baseQuery:

    // beerguide.cpp
    SqlQueryModel* breweryInfomodel = new SqlQueryModel("SELECT * FROM
brewery_info", 0);

Now in QML you have to call filter(QString, int) with the appropriate
parameters (I've modified BreweryListPage.qml again):

    function passbreweryDetails(breweryDetails)
    {
        console.log("about to push to BreweryDetailsPage, for brewery
- locid: " +
                    breweryDetails.locid + ", locname: " +
breweryDetails.locname)

        breweryInfomodel.filter("locid", breweryDetails.locid);

        pageStack.push(Qt.resolvedUrl("BreweryDetailsPage.qml"),
                       { breweryDetails : breweryDetails });
    }


Again, QSqlQueryModel does all the update stuff by itself.

Developing this idea further, you will come up with constructing the SQL
query implicitly, i.e. you pass just a table name to SqlQueryModel, then
you use role IDs or role names to refer to columns for filter() method,
then you overload filter() method to accept different data types and so on.

3. Using QSqlTableModel.

Qt has a convenient QSqlTableModel
<http://doc.qt.io/qt-5/qsqltablemodel.html> class that partly incapsulates
the things mentioned in the previous paragraph. You construct an object,
set table name, sorting column and order and call select() to populate
model. Filtering is done by calling setFilter() method but you must specify
the filters in SQL syntax (i.e. setFilter("locid = 10")). Also,
QSqlTableModel::setFilter is neither slot nor Q_INVOKABLE, so in order to
use it directly from QML you have to subclass QSqlTableModel and override
setFilter() or even make an overloaded convenience method for setFilter()
just like we did in the previous section, which could save you from some
errors. I won't give any code examples here, I bet you will easily make it
up yourself using samples in the previous sections.

Summary

There might be other ways to populate the model but these three are the
first ones that come to my mind when I think of your problem. The sample
codes are really simplistic and very specific, you might want to generalize
them in future.

So, the first method with QSortFilterProxyModel is the easiest one and
requires the least change to your code. The drawback of this method that it
might have an excessive memory footprint and it can be really slow with
large data sets --- it hardly uses any DB facilities to sort, filter or
select data.

The latter two require significant change to your backend C++ code, they
are pretty much similar in terms of performance and, let's say,
database-awareness. Though it might seem that both methods are similar, I'd
stick with the QSqlTableModel method since it's inherited by
QSqlRelationalTableModel
<http://doc.qt.io/qt-5/qsqlrelationaltablemodel.html>. I'm sure you will
find it extremely useful when dealing with locfieldid reference in
brewery_info table.

Regarding that Label delegate issue I mentioned at the beginning, I didn't
look into it but I bet the solution should simple. Actually I struggle with
QML GUI myself all the time, spend hours trying to position the items as I
want them to be. This is lack of expirience of course, I'm not using Qt GUI
at my day job at all.

Please let me know if you have any questions or need further help.

Regards
Dmitriy Purgin